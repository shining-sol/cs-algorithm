# 디자인 패턴

## 싱글턴 패턴

![image.png](attachment:27792bf2-eec0-4892-9ecf-131303e584b0:image.png)

### 특징

- 하나의 클래스에 대해 단 하나의 인스턴스만 생성되도록 보장
- 이 인스턴스에 대한 전역 접근(액세스) 지점을 제공

### 문제점

- 한 번에 두 가지의 문제를 동시에 해결함으로써 **단일 책임 원칙**을 위반

![image.png](attachment:649bfd3e-2610-4095-b757-30b70ba24bd9:image.png)

클라이언트들은 항상 같은 객체와 작업하고 있다는 사실을 인식조차 못 할 수 있습니다.

## 팩토리

![image.png](attachment:db2f1fd8-1509-4313-9f18-ec66d3796c2b:image.png)

### 특징

- 부모 클래스에서 객체들을 생성 할 수 있는 인터페이스를 제공
- 자식 클래스들이 생성될 객체들의 유형을 변경할 수 있게 가능

### 문제점

- 패턴을 구현하기 위해 많은 새로운 자식 클래스들을 도입해야 하므로 코드가 더 복잡해질 수 있음.

![image.png](attachment:6ebd3763-ac73-46bf-8535-e62a0d107314:image.png)

나머지 코드가 이미 기존 클래스들에 결합되어 있다면 프로그램에 새 클래스를 추가하는 일은 그리 간단하지 않습니다.

## 전략

### 특징

![image.png](attachment:bcdedbd0-494a-4175-befd-5dd5287aa552:image.png)

- 알고리즘들의 패밀리를 정의
- 각 패밀리를 별도의 클래스에 넣은 후 그들의 객체들을 상호교환할 수 있도록 함

### 문제점

![image.png](attachment:adb929ae-ec6f-4daa-9740-f14fa37ad770:image.png)

새로운 알고리즘을 추가할 때마다 메인 클래스의 크기가 늘어나고, 간단한 버그를 수정하거나 수치를 조정하면 전체 클래스에 영향이 미칠 수 있다.

## 옵서버

![image.png](attachment:8f54df0f-91b4-44cd-b6f3-0bb48f884db4:image.png)

### 특징

- 여러 객체에 자신이 관찰 중인 객체에 발생하는 모든 이벤트에 대하여 알리는 구독 매커니즘을 정의

### 문제점

![image.png](attachment:30d0bef4-e5f4-4423-a2f3-d8ce76e17404:image.png)

                           구독자들은 무작위 알림을 받음. 매장 방문 vs 스팸 발

## 프록시

![image.png](attachment:1eff753d-9f50-4876-a022-a851649c0a44:image.png)

### 특징

- 다른 객체에 대한 대체 또는 자리표시자를 제공할 수 있는 구조 디자인 패
- 프록시는 원래 객체에 대한 접근을 제어하므로, 당신의 요청이 원래 객체에 전달되기 전 또는 후에 무언가를 수행할 수 있도록 합니다.

### 문제점

![image.png](attachment:d6f90d8c-2e12-4142-b2fb-bf68dcd93e76:image.png)

                                   데이터 베이스 쿼리들은 정말 느릴 수 있습니다.

- 새로운 클래스들을 많이 도입해야 하므로 코드가 복잡해질 수 있습니다.
- 서비스 응답이 늦어질 수 있습니다.

# 참고 사이트

- https://refactoring.guru/ko/design-patterns

# MVC/MVP/MVVM

## MVC

MVC 패턴은 Model + View + Controller를 합친 용어입니다.

### 구조

![image.png](attachment:202966f1-243d-41c8-b82f-5f97f9b05e1f:image.png)

                            MVC는 Model + View + Controller를 말합니다.

- **Model** : 어플리케이션에서 사용되는 데이터와 그 데이터를 처리하는 부분
- **View** : 사용자에서 보여지는 UI 부분
- **Controller** : 사용자의 입력(Action)을 받고 처리하는 부분

### 동작

MVC 패턴의 동작 순서는 아래와 같습니다.

1. 사용자의 Action들은 Controller에 들어오게 됩니다.
2. Controller는 사용자의 Action를 확인하고, Model을 업데이트합니다.
3. Controller는 Model을 나타내줄 View를 선택합니다.
4. View는 Model을 이용하여 화면을 나타냅니다.

### 특징

- Controller는 여러 개의 View를 선택할 수 있는 **1:n 구조**
- Controller는 View를 선택할 뿐 **직접 업데이트 하지 않음**
- View는 Controller를 알지 못함

### 장점

- 구조가 단순하고 널리 사용됨
- 보편적으로 많이 쓰이는 가장 기본적인 디자인 패턴

### 단점

- View와 Model 사이의 **의존성이 높음**
- 어플리케이션이 커질수록 복잡해지고 유지보수가 어려워짐

---

## MVP

MVP 패턴은 Model + View + Presenter를 합친 용어입니다. Model과 View는 MVC 패턴과 동일하고, Controller 대신 Presenter가 존재합니다.

### 구조

![image.png](attachment:379353a6-c70d-4524-ab00-9200099c4296:image.png)

                               MVP는 Model + View + Presenter를 말합니다.

- **Model** : 어플리케이션에서 사용되는 데이터와 그 데이터를 처리하는 부분
- **View** : 사용자에서 보여지는 UI 부분
- **Presenter** : View에서 요청한 정보로 Model을 가공하여 View에 전달해 주는 부분 (View와 Model을 연결하는 접착제 역할)

### 동작

MVP 패턴의 동작 순서는 아래와 같습니다.

1. 사용자의 Action들은 View를 통해 들어옵니다.
2. View는 데이터를 Presenter에 요청합니다.
3. Presenter는 Model에게 데이터를 요청합니다.
4. Model은 Presenter에 데이터를 응답합니다.
5. Presenter는 View에 데이터를 전달합니다.
6. View는 Presenter가 응답한 데이터를 이용하여 화면을 나타냅니다.

### 특징

- Presenter는 View와 Model의 인스턴스를 모두 가짐 → **접착제 역할**
- Presenter와 View는 **1:1 관계**

### 장점

- View와 Model의 의존성이 없음
- MVC의 단점이었던 View-Model 의존 문제 해결

### 단점

- View와 Presenter 사이의 의존성이 높음
- 앱이 복잡해질수록 View-Presenter 사이 결합도가 강해짐

---

## MVVM

MVVM 패턴은 Model + View + ViewModel를 합친 용어입니다. Model과 View는 동일하며, ViewModel이 새롭게 등장합니다.

### 구조

![image.png](attachment:d7032bdb-13d4-4f5e-9334-b9cbd26bbbd1:image.png)

                           MVVM은 Model + View + ViewModel을 말합니다.

- **Model** : 어플리케이션에서 사용되는 데이터와 그 데이터를 처리하는 부분
- **View** : 사용자에서 보여지는 UI 부분
- **ViewModel** : View를 표현하기 위해 데이터를 가공하고, View를 위한 Model 역할을 수행

### 동작

MVVM 패턴의 동작 순서는 아래와 같습니다.

1. 사용자의 Action들은 View를 통해 들어옵니다.
2. View는 Action을 **Command 패턴**으로 ViewModel에 전달합니다.
3. ViewModel은 Model에게 데이터를 요청합니다.
4. Model은 ViewModel에 데이터를 응답합니다.
5. ViewModel은 데이터를 가공하여 저장합니다.
6. View는 ViewModel과 **Data Binding**하여 화면을 나타냅니다.

### 특징

- **Command 패턴**과 **Data Binding**을 활용
- View와 ViewModel 사이의 의존성이 줄어듦
- ViewModel과 View는 **1:n 관계**

### 장점

- View와 Model 사이의 의존성이 없음
- View와 ViewModel 사이의 의존성도 최소화
- 각 부분이 독립적이므로 모듈화 및 병렬 개발 가능

### 단점

- ViewModel의 설계가 쉽지 않음
- 잘못 설계하면 오히려 복잡도가 올라갈 수 있음

# 참고 사이트

- https://beomy.tistory.com/43

# 선언형/함수형, 객체지향, 절차형, 패러다임 혼합

## 선언형 프로그래밍 (Declarative)

### 정의

*무엇을 할지*를 표현하고, *어떻게 할지*는 숨기는 방식.

### 특징

- 절차보다는 결과에 집중
- 코드가 간결하고 가독성이 좋음
- 상태 관리와 흐름 제어를 프레임워크/엔진에 위임

### 예시

- SQL: `SELECT * FROM users WHERE age > 20`
- HTML: `<button>Click</button>`
- Android: Jetpack Compose

### 장점

- 코드 양이 적고 유지보수 쉬움
- 버그 발생 가능성이 줄어듦

### 단점

- 내부 동작을 이해하기 어려움
- 세밀한 제어가 필요할 경우 제약이 있음

---

## 함수형 프로그래밍 (Functional)

### 정의

함수를 **순수 함수(Pure Function)** 중심으로 구성하고, **불변성(Immutability)** 을 강조하는 방식.

### 특징

- 사이드 이펙트 최소화
- 고차 함수 사용 (map, filter, reduce 등)
- 상태 공유 최소화 → 병렬 처리 유리

### 예시

```kotlin
val result = listOf(1, 2, 3, 4)
    .filter { it % 2 == 0 }
    .map { it * 10 }

```

### 장점

- 병렬/비동기 처리에 적합
- 코드가 수학적 모델과 유사 → 테스트 용이

### 단점

- 러닝 커브가 있음
- 불변 객체 남발 시 메모리 낭비 가능

---

## 객체지향 프로그래밍 (OOP)

### 정의

데이터와 동작을 묶은 **객체(Object)** 중심의 프로그래밍 패러다임.

### 특징

- 주요 개념: **캡슐화, 상속, 다형성, 추상화**
- 현실 세계 모델링에 직관적
- 객체 간 메시지 전달로 동작

### 예시

```java
class Animal {
    void speak() { System.out.println("..."); }
}

class Dog extends Animal {
    @Override
    void speak() { System.out.println("Woof"); }
}

```

### 장점

- 코드 재사용성 ↑
- 유지보수와 확장 용이
- 대규모 시스템 개발에 적합

### 단점

- 과도한 상속 → 복잡성 증가
- 객체 간 의존성 높으면 결합도 ↑

---

## 절차형 프로그래밍 (Procedural)

### 정의

명령어를 순차적으로 실행하는 **절차 중심** 프로그래밍.

### 특징

- 제어 흐름(조건문, 반복문) 중심
- 함수 단위로 코드 구조화
- 작은 규모 프로그램에 적합

### 예시

```c
int sum = 0;
for(int i=0; i<10; i++) {
    sum += i;
}
printf("%d", sum);

```

### 장점

- 직관적이고 배우기 쉬움
- 작은 프로그램 작성에 적합

### 단점

- 대규모 시스템에서는 구조적 한계
- 재사용성, 유지보수성이 떨어짐

---

## 패러다임 혼합

### 정의

여러 프로그래밍 패러다임을 상황에 맞게 **조합**하는 방식.

### 특징

- 문제 성격에 따라 다른 패러다임 선택 가능
- 현대 언어들은 대부분 혼합 지원

### 예시

- **Java 8 이후**: OOP + 람다/스트림으로 FP 지원
- **Kotlin/Scala**: OOP + FP + 선언형 스타일
- **Android 개발**:
    - 아키텍처: OOP (MVVM, DI)
    - 상태 관리: 함수형 (Flow, Rx)
    - UI: 선언형 (Compose)

### 장점

- 유연성 ↑, 최적의 문제 해결 방식 선택 가능

### 단점

- 개발자가 패러다임 특성을 잘 이해하지 못하면 코드 혼란 발생
- 팀 내 합의 필요

# 참고 사이트

- GPT
