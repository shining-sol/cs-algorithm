- 싱글톤, 팩토리, 전략, 옵저버, 프록시, MVC/MVP/MVVM
- 선언형/함수형, 객체지향, 절차형, 패러다임 혼합

# 디자인 패턴

### 싱글톤

- Compose 화면이 여러 개여도 하나의 인스턴스만 참조하는 것
- 클래스의 인스턴스가 오직 하나만 생성되도록 보장하고, 전역적으로 접근할 수 있는 지점을 제공
    - 예시 - 로그인할때 사용자 이름을 마이페이지에 들고오는 것 (전역변수)

### 팩토리

- **객체를 생성하는 방법을 감춘다**
- 객체 생성 로직을 캡슐화하여 클라이언트 코드와 구체적인 클래스 간의 결합을 느슨하게
    - 호출코드를 `new` 키워드로 직접 생성하지 않고
    - **팩토리 메서드나 클래스**에게 "만들어줘"라고 요청
    - 결과물은 어떤 구체 클래스인지 몰라도 됨 → 의존성 줄어듦

```jsx
// 비행기 인터페이스
interface Plane {
    fun fly()
}

// 구체적인 비행기들
class PassengerPlane : Plane {
    override fun fly() = println("승객을 태우고 비행합니다.")
}

class CargoPlane : Plane {
    override fun fly() = println("화물을 싣고 비행합니다.")
}

class FighterPlane : Plane {
    override fun fly() = println("초고속으로 전투 비행합니다.")
}

// 팩토리
object PlaneFactory {
    fun createPlane(type: String): Plane = when (type) {
        "passenger" -> PassengerPlane()
        "cargo" -> CargoPlane()
        "fighter" -> FighterPlane()
        else -> throw IllegalArgumentException("알 수 없는 비행기 타입")
    }
}

// 클라이언트
fun main() {
    val plane1 = PlaneFactory.createPlane("passenger")
    val plane2 = PlaneFactory.createPlane("fighter")

    plane1.fly() // 승객을 태우고 비행합니다.
    plane2.fly() // 초고속으로 전투 비행합니다.
}
```

### 전략

- 알고리즘 군을 정의하고 각각을 캡슐화하여 상호 교환 가능하게 만듭니다.

### 옵저버

- 객체 간의 일대다 의존 관계를 정의하여 한 객체의 상태가 변할 때 관련된 모든 객체에 자동으로 알림을 보냅니다.
    - livedata

### 프록시

- 다른 객체에 대한 접근을 제어하기 위해 **대리자**를 제공합니다.

# 아키텍처 패턴 MVC/MVP/MVVM

### MVC (Model-View-Controller)


- **MVC는 Model-View-Controller로 애플리케이션을 세 가지의 계층으로 구분한 방법론을 의미합니다.**
- 사용자가 처음 페이지를 출력하는 경우 Controller로 요청이 발생하고 Model에서 데이터를 가져와서 그 정보를 바탕으로 시각적 표현인 View를 그려주는 아키텍처 패턴을 의미합니다.

| **계층** | **설명** |
| --- | --- |
| **Model** | 애플리케이션에서 데이터를 저장하고 처리하는 계층을 의미합니다. |
| **View** | 애플리케이션에서 사용자가 직접 보는 화면(UI)을 담당하는 계층을 의미합니다. |
| **Controller** | 뷰와 모델간의 관계를 설정하는 계층이며 해당 부분에서 애플리케이션의 로직을 담당하는 계층을 의미합니다. 
(View에서 UI를 갱신하고 Model에서는 데이터를 업데이트 하는 구조입니다.) |

### MVP (Model-View-Presenter)


- MVP는 Model-View-Presenter로 애플리케이션을 세 가지의 계층으로 구분한 방법론을 의미합니다
- UI(View)와 모델(Model)을 분리하고 서로 간에 상호작용을 'Presenter'에서 그 역할을 해줌으로써 서로 간의 의존성을 최소화하는 특징이 있는 아키텍처 패턴이다.

| **계층** | **설명** |
| --- | --- |
| **Model** | 애플리케이션에서 데이터를 저장하고 처리하는 계층을 의미합니다. |
| **View** | 애플리케이션에서 사용자가 직접 보는 화면(UI)을 담당하는 계층을 의미합니다. |
| **Presenter** | - 해당 계층에서는 뷰와 모델을 완전히 분리하고 서로간의 의존성을 없앴습니다.(View - Presenter / Model - Presenter 구조 - 인터페이스로 구성되어 있습니다.)

- Presenter는 Model을 참조하고 있다가 Update가 발생시 View를 업데이트를 합니다.또한 Presenter는 이벤트 발생시 View를 참조해서 Model의 데이터를 업데이트를 합니다. |

### MVVM (Model-View-ViewModel)


| **계층** | **설명** |
| --- | --- |
| **Model** | 애플리케이션에서 데이터를 저장하고 처리하는 계층을 의미합니다. |
| **ViewModel** | 애플리케이션에서 View와 Model 사이에 존재하며 서로간의 중재를 하는 역할을 수행합니다.
• **View - ViewModel** : 사용자와의 뷰의 상호작용(클릭, 키보드 등작 등)을 수신하여 이에 대한 처리를 View와 ViewModel을 연결하고 있는 데이터 바인딩을 통해 서로간을 연결합니다.
• **Model - ViewModel**: 사용자의 데이터의 변경이 발생하는 경우 데이터를 가져오거나 갱신 한 뒤 View에게 전달하여 사용자에게 전달하는 역할을 수행합니다. |
| **View** | 애플리케이션에서 사용자가 직접 보는 화면(UI)을 담당하는 계층을 의미합니다. |

# 패러다임

- 패러다임 : 코드 작성 스타일

| 패러다임 | 설명 | 코틀린 예시 |
| --- | --- | --- |
| **명령형(Imperative)** | "어떻게 할지"를 절차적으로 작성 | `for (i in 1..5) { println(i) }` |
| **선언형(Declarative)** | "무엇을 할지"를 선언, 세부 절차는 숨김 | `(1..5).forEach { println(it) }` |
| **객체지향(OOP)** | 데이터+행동을 객체로 묶어 표현 | `class Dog { fun bark() { println("멍멍") } }` |
| **함수형(Functional)** | 상태 변경 최소화, 순수 함수 중심 | `listOf(1,2,3).map { it * 2 }` |
| **절차적(Procedural)** | 함수를 중심으로 절차적으로 코드 작성 | `fun calculate() { step1(); step2() }` |
