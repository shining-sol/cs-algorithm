## 디자인 패턴

소프트웨어 개발 과정에서 자주 등장하는 문제를 재사용 가능한 설계 방법(템플릿)으로 정리한 것. 

언어에 상관없이 적용 가능하며 특정 상황에서 객체 및 클래스 관계를 효과적으로 구성하는 설계법

- 싱글톤
    
    정의 : 애플리케이션 전역에서 단 하나의 인스턴스만 존재하게 보장하는 패턴.
    
    공용설정, 로깅, 캐시, 스레드 풀, DB 커넥션 풀처럼 “하나만” 있어야 할 때
    
    생성자를 private으로 막고, 정적 접근점으로 동일 객체를 반환
    
    멀티스레드 환경에서 안전하게 초기화 해야함
    
    장점 : 전역 공유, 생성 비용 절약
    
    단점 : 전역 상태로 인한 결합도 상승, 테스트/병렬성 저해, 숨은 의존성
    

- 팩토리
    
    정의 : 객체 생성 로직을 캡슐화 해 클라이언트가 “무엇”을 생성하는지만 알게 하는 패턴.
    생성 과정이 복잡하거나 , 구체 클래스를 숨기고 인터페이스만 노출하고 싶을 때
    
    Simple Factory : 분기문으로 구현 선택
    Factory Method : 하위 클래스가 생성 책임 가짐
    Abstract Factory : 관련 객체의 가족을 한 번에 생성
    
    장점 : 생성/구현 분리로 유연성 상승, 테스트 용이
    
    단점 : 클래스 수 증가해 과도하면 복잡도가 상승함.
    

- 전략
    
    정의 : 알고리즘군을 인터페이스로 추상화하고, 런타임에 교체 가능한 패턴
    동작은 같지만 방식이 여러개 일 때 사용(정렬 기준, 결제 수단, 할인 정책 등)
    
    context가 Strategy 인터페이스를 참조
    
    장점 : if-else 제거, 개방-폐쇄 원칙(OCP) 충족
    단점 : 전략 클래스/파일이 많아질 수 있음.
    
- 옵저버
    
    정의 : 주체(Subject)의 상태 변경을 여러 관찰자가 자동으로 통지받는 패턴
    이벤트 브로드캐스팅, 상태 변화에 반응하는 UI/실시간 시스템
    
    Subject가 Observer 목록을 관리하고 notify()로 알림
    push/pull 모델 가능
    
    장점 : 느슨한 결합, 반응형 UI에 적합함
    단점 : 이벤트 폭주 순서 이슈, 디버깅 난이도 상승
    

- 프록시
    
    정의 : 실제 객체 대리인을 둬 접근 전후 제어(캐싱/권한/지연 로딩/리모트 호출)를 수행하는 패턴
    원격 서비스 호출, 무거운 객체의 지연 초기화, 접근 제어, 로깅/트랜잭션 단면
    
    클라이언트는 원본과 동일한 인터페이스에 의존 → 프록시가 가로채어 부가 로직 실행
    정적 프록시/동적 프록시
    
    장점: 횡단 관심사 삽입 용이, 성능(캐시) 보안 이점
    단점 : 계층이 깊어지면 추적이 어려움, 프록시 남용 주의
    
- MVC / MVP / MVVM
    
    MVC : Model(데이터/로직), View(UI), Controller(입력 처리)
    
    장점 : 역할 분리, 대중적
    단점 : 대규모에서 Controller 비대화, View-Controller 의존 얽힘
    
    MVP : View(UI), Presenter가 로직 담당
    
    장점 : UI 테스트 쉬움, View Mock으로 단위 테스트 
    단점 : Presenter가 비대해지기 쉬움
    
    MVVM : View ↔ ViewModel 간 양항뱡 바인딩
    
    ViewModel + LivaData/StateFlow + Repository
    
    Compose : 상태 호이스팅 + 단반향 데이터 흐름(UDF)
    

## 프로그래밍 패러다임

프로그래밍을 어떤 관점 및 사고방식으로 접근하느냐를 말함. 즉 코드를 짜는 철학 스타일이라고 할 수 있음.

- 선언형
    
    정의 : “무엇을 할지” 만 정의, “어떻게 할지” 는 언어/엔진이 처리
    명령어 흐름이 아니라 결과 중심
    
    장점 : 가독성 증가, 유지보수 용이, 추상화 수준 증가
    단점 : 세밀한 제어가 어려움, 내부 동작 이해 부족시 성능 튜닝 난이도 상승
    

- 함수형
    
    정의 : 수학적 함수처럼 동작. 입력 → 출럭, 부작용(side-effect) 최소화
    순수 함수 : 같은 입력 → 항상 같은 출력, 외부 상태 영향X
    고차 함수 : 함수를 인자로받거나 반환
    불변성 : 데이터 변경 대신 새로운 값 생성
    
    장점: 병렬 처리 유리, 디버깅 쉬움, 테스트 용이.
    단점 : 러닝커브 증가, 메모리/성능 오버헤드
    

- 객체 지향
    
    정의 : 객체(데이터 + 행동)의 협력으로 시스템을 모델링.
    
    캡슐화 : 데이터와 메스드를 객체 안에 감싸 보호(getter/setter)
    
    상속 : 상위 클래스의 속성과 동작을 재사용/확장
    
    다형성 : 같은 메서드 호출이 객체 타입에 따라 다르게 동작
    
    추상화 : 공통 속성을 뽑아내어 단순화(interface/abstract class)
    
    장점 : 재사용성 ↑, 유지 보수성 ↑ , 현실 세계 모델링 용이
    단점 : 설계가 복잡 , 성능 감소, 잘못 쓰면 의존서 ↑
    

- 절차형
    
    정의 : 프로그램을 절차(순서) 중심으로 구성
    
    함수/조건문/반복문으로 단계적 실행
    
    장점 : 단순하고 빠름
    단점 : 규모가 커질 시 관리 어려움.
    

- 패러다임 혼합
    
    현대 언어 대부분 혼합형 
    Python : 절차형 + OOP + 함수형
    Java/Kotlin : OOP + 함수형(람다, Stream, Coroutines)
    JavaScript : 함수형 + 객체 기반 + 이벤트 지향