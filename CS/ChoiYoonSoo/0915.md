# 1일차

생성일: 2025년 9월 8일 오전 4:24

# 디자인 패턴

> 소프트웨어 설계에서 반복적으로 발생하는 문제들을 효과적으로 해결하기 위해 일반화된 재사용 가능한 솔루션
> 

## 싱글톤 패턴(Singleton pattern)

> 특정 클래스에 객체 인스턴스를 하나만 생성하도록 보장하는 패턴
> 

> 생성자를 통해서 여러 번 호출이 되더라도 인스턴스를 새로 생성하지 않고 최초 호출 시에 만들어두었던 인스턴스를 재활용하는 패턴
> 

> 싱글톤 패턴을 사용하면 전역 변수를 사용할 때와 마찬가지로 객체 인스턴스를 어디서든지 액세스 할 수 있게 만들 수 있다.
> 

> 어플리케이션의 시작부터 종료까지 1번의 생성으로 고정된 메모리 영역을 가지므로 메모리를 효율적으로 사용할 수 있다 (Android 관점)
> 

## 싱글톤 패턴을 사용하는 이유?

1. 메모리 낭비 방지
    1. 한 번도 사용하지 않을 경우 인스턴스를 아예 생성하지 않는다.
    2. 사용자가 1초에 10번 똑같은 요청을 보내면 요청을 처리하기 위한 똑같은 객체를 1초에 10번 생성하고 소멸되는 메모리 낭비 문제가 발생하는데 →
    싱글톤 패턴을 사용하면 최초 한번 new로 객체를 생성하고 해당 객체를 이후에도 사용하도록 공유(static)하면 메모리 낭비 문제를 방지할 수 있다.
2. 싱글톤으로 만들어진 클래스의 인스턴스는 전역 인스턴스이기 때문에 다른 클래스들의 인스턴스들이 데이터를 공유하기 쉽다.
3. 싱글턴은 런타임에 초기화(사용 직전에 초기화)된다. → 게으른 초기화 → 정적 변수로만 초기화가 이루어질 경우 이 변수들의 초기화 순서는 매번 달라지는데 이 때 한 정적 변수가 다른 정적 변수에 의존하게 만들 수가 없는 문제점을 막아준다.
4. DBCP(DataBase Connection Pool)처럼 공통된 객체를 여러개 생성해서 사용해야하는 상황에서 많이 사용(쓰레드풀, 캐시, 대화상자, 사용자 설정, 레지스트리 설정, 로그 기록 객체 등)

## 싱글톤 패턴은 어디서 사용될까?

1. 네트워크 클라이언트
    1. 한 번의 설정으로 어디서나 사용 가능
    
    **ex)** `DB 커넥션 풀`, `Retrofit/OkHTTP` , `Room`  인스턴스 등은 생성 비용이 크기 때문에 한 번 만들어 앱 전역에서 재사용
    
2. 데이터베이스 접근 객체
    1. 동일한 인스턴스를 사용하여 일관성을 유지
3. 공통 설정 관리
    1. 전역 설정 값을 저장하고 사용
4. 공용 캐시나 이미지 로더
    1. 메모리 효율성을 높이고 일관된 데이터 접근

## 싱글톤 패턴의 문제점

1. 싱글톤 인스턴스가 너무 많은 일을 하거나 많은 데이터를 공유시킬 경우 다른 클래스들의 인스턴스들 간에 결합도가 높아져 개방 폐쇄 원칙을 위배하게 된다.
2. 수정이 어려워지고 테스트하기 어렵다.
3. 멀티스레드 환경에서 여러 개의 스레드가 싱글톤 인스턴스에 동시에 접근할 경우 인스턴스가 여러 번 생성될 수 있다. 이 문제를 해결하기 위해서는 동기화 처리를 해주어야 하는데 이 처리 자체가 성능에 영향을 미칠 수 있다.
4. 싱글톤은 자신만이 객체를 생성할 수 있도록 생성자를 `private` 으로 제한한다. 하지만 상속을 통해 다형성을 적용하기 위해서는 다른 기본생성자가 필요하므로 객체지향의 장점을 적용할 수 없다.
5. 복잡한 구현 코드

## Kotlin Singleton Class

1. **object**
    
    `object`키워드를 사용해서 싱글톤 클래스를 생성
    이는 클래스 전체를 싱글톤으로 사용할 때 유용하다.
    
    **ex)** 간단한 유틸리티 클래스
    

```kotlin
object AppUtils {
	var isDebugMode = false
	fun getCurrentTimestamp(): Long {
		return System.currentTimeMillis()
	}
}
```

1. **companion object**
    
    코틀린에서 `companion object`는 클래스 내부에 싱글톤을 정의할 때 사용
    
    이는 클래스와 강하게 결합된 정적 멤버를 정의할 때 유용하다.
    
    **ex)** 클래스와 밀접한 정적 멤버 및 초기화 비용이 큰 객체
    
    ```kotlin
    class ConfigManager private constructor() {
    	companion object {
    		val instance: ConfigManager by lazy { ConfigManager() }
    	}
    	
    	fun loadConfig() {
    	
    	}
    }
    ```
    

1. **enum class**
    
    자바에서 사용했던 방법 중에 하나로 enum class를 사용해서 싱글톤을 구현
    
    enum class를 사용한 싱글톤은 Serializable 인터페이스를 상속받아 직렬화 및 역직렬화를 활용
    
    **ex)** 자바와 호환성 및 직렬화가 필요한 경우
    
    ```kotlin
    enum class AppStatus {
    	INSTANCE;
    	
    	var currentState = 0
    	
    	fun chageState(newState: State) {
    		currentState = newState
    	}
    }
    ```
    

![image.png](image.png)

## 팩토리 패턴(Factory pattern)

> 객체를 생성하는 디자인 패턴 중 하나
> 

> 객체를 생성하는 과정을 캡슐화하여 클라이언트가 직접 객체를 생성하는 것이 아니라 생성 로직을 분리해서 객체를 요청하고 생성하는 디자인 패턴
> 

> 이를 통해 객체 생성의 유연성을 높이고 의존성을 줄이며 코드의 확장성을 향상시킨다.
> 

## 팩토리 패턴 주요 역할

1. 팩토리 패턴을 사용하여 생성 과정을 캡슐화할 수 있다. 이때 생성 과정의 변경사항은 호출자에게 투명성을 가진다.
2. 생성 과정을 팩토리 클래스로 추출한 후 재사용할 수 있다.
3. 복잡한 생성 과정을 캡슐화하므로 호출자는 객체 생성 방법을 알 필요가 없다.
4. 생성 과정과 사용 과정을 분리하여 복잡한 코드를 간결하게 바꿀 수 있다.

## 팩토리 패턴 종류

1. 단순 팩토리 패턴(Simple Factory Pattern)
2. 팩토리 메소드 패턴(Factory Method Pattern)
3. 추상 팩토리 패턴(Abstract Factory Pattern)

## 단순 팩토리 패턴(Simple Factory Pattern)

> 하나의 팩토리 클래스가 다양한 객체를 생성하는 것을 다룸
> 

> 클라이언트는 생성할 객체의 타입을 팩토리에게 전달하고 팩토리는 그에 해당하는 객체를 반환한다.
> 

## 팩토리 메소드 패턴(Factory Method Pattern)

> 생성 패턴 중 하나로 객체를 생성할 때 어떤 클래스의 인스턴스를 만드는지는 `서브클래스`에서 결정
즉, 클래스의 인스턴스를 만드는 일을 `서브클래스`에게 맡기는 것
> 

> 부모 추상 클래스는 인터페이스에만 의존하고 실제로 어떤 구현 클래스를 호출할 지는 서브 클래스에서 구현한다.
이렇게 하면 새로운 구현 클래스가 추가되어도 기존 Factory 코드의 수정 없이 새로운 Factory를 추가하면 된다.
> 

## 추상 팩토리 패턴(Abstract Factory Pattern)

> 여러 종류의 관련된 객체를 생성하는 팩토리를 제공
> 

> 팩토리를 추상화하여 클라이언트가 인터페이스를 통해 여러 종류의 객체를 생성할 수 있도록 한다.
> 

## 팩토리 패턴 사용 이유?

- 어떠한 클래스를 만들 때 타입을 미리 알 수 없는 경우
- 어떠한 클래스를 만들고 해당 클래스가 연속적인 클래스를 필요한 경우
- 어떠한 클래스를 특정하기 위해 서브 클래스가 필요한 경우
- 또는 복잡한 클래스 내부 구조를 간단하게 만들기 위한 경우

## 팩토리 패턴의 장점

1. 생성 로직의 분리
    1. 객체 생성과 비즈니스 로직이 분리되어 코드 관리가 용이진다.
2. 코드의 유연성
    1. 새로운 객체 타입을 추가하거나 변경할 때 기존 코드를 변경하지 않아도 된다.
3. 재사용성 향상
    1. 동일한 생성 패턴을 여러 곳에서 재사용할 수 있다.

## 팩토리 패턴의 단점

1. 클래스 수 증가
    1. 팩토리 클래스 자체가 추가되기 때문에 코드의 양이 늘어나고 관리할 클래스가 많아진다.
    2. 간단한 객체 생성이 필요한 경우에는 비효율적이다.
2. 인터페이스 의존성
    1. 단순한 클래스 인터스화보다 더 많은 코드가 필요하게 되며 작은 프로젝트에는 오히려 불필요한 복잡성을 유발

## 전략 패턴(Strategy pattern)

> 객체들이 할 수 있는 행위 각각에 대해 전략 클래스를 생성하고 유사한 행위들을 캡슐화 하는 인터페이스를 정의하며
> 

> 객체의 행위를 동적으로 바꾸고 싶은 경우 직접 행위를 수정하지 않고 전략만 바꿔주면 행위를 유연하게 확장하는 방법.
> 

> 전략 패턴은 실행(런타임) 중에 알고리즘 전략을 선택하여 객체 동작을 실시간으로 바뀌도록 할 수 있게 하는 행위 디자인 패턴이다.
> 

> 어떤 일을 수행하는 알고리즘이 여러가지 일때, 미리 전략으로 정의함으로써 손쉽게 전략을 교체할 수 있는 알고리즘 변형이 빈번하게 필요한 경우에 적합한 패턴
> 

## 전략 패턴 구성요소

1. **Context**
    1. 클라이언트가 사용하는 인터페이스를 제공
    2. `Context는 Strategy`를 사용하여 알고리즘을 실행합니다.
2. **Strategy Interface**
    1. 모든 `Concrete Strategy`가 구현해야 하는 공통 인터페이스
    2. 이 인터페이스는 `Context`가 알고리즘을 호출하는 
3. **Concrete Strategy**
    1. `Strategy` 인터페이스를 구현하는 클래스로 실제 알고리즘을 실행

## 전략 패턴 사용시기

- 전략 알고리즘의 여러 버전 또는 변형이 필요할 때 클래스화를 통해 관리
- 알고리즘 코드가 노출되어서는 안되는 데이터에 엑세스 하거나 데이터를 활용할 때
- 일부 행동을 실행하는 방식에서만 차이가 있는 유사한 클래스들이 많은 경우

## 전략 패턴 장점

- 런타임에 한 객체 내부에서 사용되는 알고리즘들을 교환할 수 있다.
- 알고리즘의 구현 세부 정보들을 고립할 수 있다.
- OCP(개방-폐쇄 원칙) 콘텍스트를 변경하지 않고도 새로운 전략을 도입하여 구현할 수 있다.

## 전략 패턴 단점

- 알고리즘이 많지 않고 거의 변하지 않는다면 새로운 클래스와 인터페이스로 인해 프로그램이 더욱 복잡해질 수 있다.
- 통신 오버헤드가 클 수도 있다.
- 클라이언트들은 적절한 전략을 선택해야하고 전략 간의 차이점들을 알아야 한다.

## 옵저버 패턴(Observer pattern)

> 객체의 상태 변화를 관찰하는 관찰자들
즉, 옵저버들의 목록을 객체에 등록하여 상태 변화가 있을 때마다 메서드 등을 통해 객체가 직접 목록의 각 옵저버에게 통지하도록 하는 디자인 패턴
> 

## 옵저버 패턴 구성요소

1. **Subject(주체)** 
    1. 상태를 관리하며 상태 변화 시 옵저버들에게 알림을 보내는 역할을 수행
2. **Observer(관찰자)**
    1. 주체의 상태 변화를 관찰하며 변경 사항을 수신하는 역할을 수행

## 옵저버 패턴 흐름

1. `Subject(주체)`의 상태가 변경된다.(이벤트 발생)
2. `Subject(주체)`는 자신의 상태가 변경되면 즉시 `Observer(관찰자)`에게 통지한다,
3. `Observer(관찰자)`는 `Subject(주체)`의 상태 변경을 감지하고 이에 대응한다.

## 옵저버 패턴 장점

1. 실시간으로 한 객체의 변경사항을 다른 객체에 전파할 수 있다.
2. `느슨한 결합`(Loose Coupling)으로 주체와 옵저버는 서로에 대해 정보를 몰라도 상호작용할 수 있어 객체 간의 결합도가 낮다.
    1. `느슨한 결합`이란?
        1. 다른 클래스를 직접적으로 사용하는 클래스의 의존성을 줄이는 것
3. 새로운 옵저버를 쉽게 추가할 수 있으며 주체의 동작을 변경하지 않고도 여러 옵저버가 같은 주체를 관찰할 수 있다.

## 옵저버 패턴 단점

1. 옵저버의 수가 많아지면 주체가 상태 변화를 알릴 때 성능에 영향을 미칠 수 있다.
2. 옵저버가 주체의 상태 변화에 지나치게 의존하게 될 경우 시스템이 복잡해진다.

## 안드로이드 옵저버 패턴

1. 사용자가 키보드를 눌렀을 때
2. 사용자가 버튼을 터치했을 때
3. 호출한 API의 응답 데이터가 수신됐을 때

> 다음과 같은 이벤트가 발생할때마다 즉각 처리하도록 만드는 패턴이 `옵저버 패턴`
> 

안드로이드에서는

1. RxJava의 Observable
2. Coroutines의 Flow
3. Kotlin에 기본으로 내장된 ObservableProperty

등 가장 많이 사용되는 데이터들은 모두 같은 방식으로 구현된다,

RxJava에서는 Observable을 통해 발행자를 생성하고 subscribe를 통해 구독자를 붙인다.

```kotlin
//발행자(Publisher)
val publisher : Observable<String> = Observable.create { emitter: ObservableEmitter<String> ->
    emitter.onNext("hello")
    emitter.onNext("kotlin")
    emitter.onComplete()
}

//구독자(Subscriber)
publisher.subscribe {
    println(it)
}

//출력
hello
kotlin
```

Coroutine에서는 Flow를 통해 발행자를 생성하고 collect를 통해 구독자를 붙인다.

```kotlin
//발행자(Publisher)
val flow = flow {
   emit("abc")
   emit("def") 
}

CoroutineScope(Dispatchers.IO).launch {
    //구독자(Subscriber)
    flow.collect {
        println(it)
    }
}

//출력
abc
def
```

Kotlin의 Delegates.observable은 시작값(initalValue)과, 변경 시 동작(onChange)을 인자로 받는다.

값(data) 자체가 발행자이며 변경 시 동작(onChange)을 구독자로 생각하면 된다.

```kotlin
var data: String by Delegates.observable(
    initialValue = "",
    //onChange : 구독자
    onChange = { property: KProperty<*>, oldValue: String, newValue: String ->
        println("Data Changed >> from ${oldValue} to ${newValue}")
    }
)
```

## 프록시 패턴(Proxy pattern)

> 프록시(Proxy)는 대리자, 대변인이라는 뜻을 가진다.
대리자/대변인은 다른 누군가를 대신해 그 역할을 수행하는 존재를 말한다.
따라서 프록시 패턴은 객체 간의 간접적인 접근을 가능하게 하는 구조를 제공하는 패턴이다.
> 

> 어떤 객체를 호출할 때 객체를 직접 호출하는 것이 아니라 대리자 객체를 호출하는 방식을 사용하면 해당 객체가 메모리에 존재하지 않아도 기본적인 정보를 참조하거나 설정할 수 있다.
또, 실제 객체의 필요 시점까지 객체 생성을 미루는 `지연 초기화(Lazy Initializing)`가 가능하다
> 

## 프록시 패턴 장점

1. 접근 제어
    1. 클라이언트가 실제 객체에 직접 접근하지 않도록 제어하여 객체의 접근을 관리하고 권한 검사 등을 수행할 수 있다.
2. 지연 초기화
    1. 실제 객체의 생성 및 초기화를 지연시키는 데 사용하여 필요한 순간만에 생성 및 초기화하여 성능을 최적화할 수 있다.
3. 캐싱
    1. 결과를 캐싱하여 중복 계산을 피하고 성능을 향상시킬 수 있다.
4. 유효성 검사
    1. 실제 객체에 접근하기 전에 데이터의 유효성 검사를 통해 검증할 수 있다.
5. 원격 액세스
    1. 원격 프록시를 사용하여 다른 시스템에서 실행 중인 객체에 접근할 수 있으며 분산 시스템에서 객체 간 통신을 용이하게 한다.

## 프록시 패턴 단점

1. 복잡성 증가
    1. 추가적인 객체를 도입하기 때문에 코드의 복잡성이 증가할 수 있다.
2. 성능 저하
    1. 프록시 객체에 접근하는 데 추가적인 오버헤드가 발생할 수 있으며 일부 성능 저하가 발생할 수 있다.
3. 디자인 복잡성
    1. 프록시 패턴을 오용하면 코드를 과도하게 복잡하게 만들 수 있다.

## 프록시 패턴의 종류

**가상프록시**

> 꼭 필요로 하는 시점까지 객체의 생성을 연기하고 해당 객체가 생성된 것 처럼 동작하도록 만들고 싶을 때 사용하는 패턴
> 

**원격프록시**

> 서로 다른 주소 공간에 있는 객체에 대해 마치 같은 주소 공간에 있는 것 처럼 동작하게 하는 패턴
> 

**보호프록시**

> 주체 클래스에 대한 접근을 제어하기 위한 경우에 객체에 대한 접근 권한을 제어하거나 객체마다 접근 권한을 달리하고 싶을 경우 사용하는 패턴
> 

## MVC 패턴(**M**odel / **V**iew / **C**ontroller)

> 컴퓨터공학에서 소프트웨어 설계와 아키텍처를 위한 디자인 패턴 중 하나
주로 사용자 인터페이스(UI)를 가진 응용 프로그램에 사용
애플리케이션의 개발과 유지 보수를 쉽게 하기 위해 데이터, 프레젠테이션, 프로세싱을 서로 분리
> 

## 모델(Model)

> 애플리케이션의 핵심 데이터와 비즈니스 로직을 나타낸다.
데이터 저장소와의 상호 작용, 데이터 처리(저장, 검색, 수정 등) 및 유효성 검사와 같은 작업 수행
모델은 독립적으로 작동하며 뷰와 컨트롤러와 직접적으로 통신하지 않는다.
> 

## 뷰(View)

> 뷰는 사용자에게 보여지는 애플리케이션 UI 부분
뷰는 모델에서 데이터를 받아 사용자에게 표시하고 사용자의 입력을 컨트롤러에서 전달한다.
뷰는 애플리케이션의 데이터 표시와 관련된 모든 작업을 처리한다.
> 

## 컨트롤러(Controller)

> 컨트롤러는 사용자 입력을 처리하고 애플리케이션의 흐름을 관리한다.
뷰에서 전달된 사용자 입력을 분석하고 적절한 모델 기능을 호출하여 데이터를 조작하거나 업데이트한다.
그런 다음 결과를 다시 뷰에 전달하여 화면에 표시
> 

## M-V-C의 상호작용

> 사용자가 애플리케이션에서 작업을 수행하면
`뷰(View)`는 사용자의 입력을 감지하고
`컨트롤러(Controller)`에 전달한다.

컨트롤러는 사용자 입력을 처리하고 적절한 `모델(Model)` 기능을 호출하여 데이터를 검색, 수정 또는 저장한다.

모델은 데이터와 관련된 비즈니스 로직을 수행하고 필요한 경우 데이터베이스와 상호 작용한다.
모델은 작업이 완료되면 결과를 컨트롤러에 반환한다.

컨트롤러는 모델의 결과를 받아 뷰에 전달 → 뷰는 이 데이터를 사용하여 사용자에게 보여지는 화면을 업데이트
> 

## MVC 패턴의 설계 원칙

1. 각 구성 요소의 역할과 책임을 명확하게 구분
    1. 모델, 뷰, 컨트롤러는 독립적으로 작동
2. 구성 요소간의 결합도 최소화
    1. 독립적으로 개발, 수정, 테스트할 수 있어야 함(이벤트 기반 통신, 옵저버 패턴, 의존성 주입 등)
3. 코드의 재사용성과 확장성 고려
    1. 독립적이고 재사용 가능한 모듈로 개발되어야 함 → 쉽게 확장 및 수정을 위함

## MVC 패턴의 장점

- 각 구성 요소의 역할이 명확하게 분리되어 있어 코드의 가독성과 유지 관리가 용이하다.
- 구성 요소간의 낮은 결합도로 인해 코드의 재사용성이 높아지며 개별 구성 요소를 독립적으로 개발, 수정 및 테스트할 수 있다.
- 동일한 모델을 여러 뷰에서 사용할 수 있으므로 애플리케이션의 유연성이 향상된다.

## MVP 패턴(Model / View / Presenter)

> Model과 View는 MVC 패턴과 동일하고 Controller 대신 Presenter가 존재
MVC는 Model이 View를 직접 컨트롤 할 수 있지만 MVP는 직접 컨트롤 할 수 없다.
> 

![image.png](image%201.png)

## Model

> 데이터와 비즈니스 로직을 담당
데이터를 가져오고 저장하는 역할을 수행
데이터베이스, 네트워크 요청 또는 파일 시스템과 같은 데이터 소스와 상호 작용
> 

## View

> 사용자 인터페이스를 담당하는 부분
사용자가 보는 화면을 표시하고 사용자 입력을 처리하며 Presenter에 의해 보여질 데이터를 표시하는 등의 역할을 수행
사용자의 행동은 Presenter에 의해 처리되도록 설계되어야 함
> 

## Presenter

> View와 Model 사이에서 중재자 역할
사용자와 인터페이스의 이벤트를 감지하고 해당 이벤트를 처리하는 비즈니스 로직을 수행
Model과 상호작용하여 데이터를 가져오거나 업데이트하고 View에 데이터를 업데이트 하는 역할
> 

## MVP 동작 과정

![image.png](image%202.png)

1. 사용자의 Action들은 View를 통해 들어온다.
2. View는 데이터를 Presenter에 요청
3. Presenter는 Model에게 데이터를 요청
4. Model은 Presenter에서 요청받은 데이터를 응답
5. Presenter은 View에게 데이터를 응답
6. View는 Presenter가 응답한 데이터를 이용하여 화면을 나타냄

## MVC 말고 MVP 쓰는 이유

1. 분리된 책임(Separation of Concerns)
    
    MVP 패턴은 비즈니스 로직(Model)과 사용자 인터페이스(View)가 분리하여 관리하므로 코드의 가독성과 유지보수성이 향상된다.
    
    - MVC는 Model과 View가 서로 연결되어 있어 의존관계를 갖게 됨
    - MVP는 Model과 View가 분리되어 있고 오직 Presenter를 통해서 상태나 변화를 알려줄 수 있다.
2. 테스트 용이성
    
    View와 Presenter가 독립적으로 동작하므로 단위 테스트를 작성하기가 쉽다.
    
    Presenter는 View를 모의(Mock)해서 테스트할 수 있으며 Model은 별도로 테스트할 수 있다.
    

## MVP 장점

1. View와 Model간의 의존성이 없고 UI와 비즈니스 로직을 구분했기 때문에 유닛 테스트가 용이하다
2. 개발자들 간의 협업이 쉬워진다
3. 코드를 분리함으로써 유지보수성과 확장성이 향상된다.

## MVP 단점

1. View와 Presenter는 1대1 관계이기 때문에 Presenter를 재사용 할 수 없다.
2. 기능이 많아질수록 Presenter가 거대해지는 단점이 있다.
3. 프로젝트의 규모가 커질 수록 MVP 패턴 구조를 유지하고 관리하는 것이 어려워질 수 있다.
4. View가 늘어날때 마다 Presenter도 늘어나 클래스가 많아진다.

## MVVM 패턴(Model / View / ViewModel)

> `Model View`, `View`, `Model`의 약자로 프로그램의 비즈니스 로직과 프레젠테이션 로직을 UI로 명확하게 분리하는 패턴
> 

## Model

> 데이터와 비즈니스 로직을 담당
데이터를 가져오고 저장하는 역할을 수행
데이터베이스, 네트워크 요청 또는 파일 시스템과 같은 데이터 소스와 상호 작용
> 

## View

> 사용자 인터페이스를 담당하는 부분
사용자가 보는 화면을 표시하고 사용자 입력을 처리
> 

## ViewModel

> View와 Model 사이에서 중재자 역할을 수행
View에서 발생하는 이벤트를 감지하고 해당 이벤트에 맞는 비즈니스 로직을 수행
Model과 상호작용하여 데이터를 가져오거나 업데이트하고 View에 데이터를 업데이트하는 역할
View에 표시할 데이터를 가공하여 제공하는 역할
> 

## MVVM 동작 과정

![image.png](image%203.png)

1. 사용자의 Action들은 View를 통해 들어옴
2. View에 Action이 들어오면 ViewModel에 Action을 전달
3. ViewModel은 Model에게 데이터를 요청
4. Model은 ViewModel에게 요청받은 데이터를 응답
5. ViewModel은 응답 받은 데이터를 가공하여 저장
6. View는 Data Binding을 이용해 UI를 갱신

## MVVM 특징

> MVP와 비슷한 부분이 많지만 MVP는 View와 Presenter 사이의 의존관계가 1:1로 형성되어 있다면
MVVM은 View와 ViewModel 사이의 관계가 1대N으로 되어있다.
또한 데이터 바인딩을 이용한다면 View와 ViewModel 사이의 의존성을 없앨 수 있다.
> 

## MVVM 장점

1. 뷰 로직과 비즈니스 로직을 분리하여 생산성을 높힐 수 있다. (UI가 나오지 않아도 개발 가능)
2. 테스트가 수월해진다. (의존성이 없기 때문)
3. 뷰와 뷰모델이 1:N 관계이기 때문에 중복되는 로직을 모듈화 해서 여러 뷰에 적용할 수 있다. (코드 재사용 가능)
4. 많은 기업들이 애용하는 디자인 패턴이다.

## MVVM 단점

1. 설계하기가 복잡하다. (Rx, 데이터 바인딩에 대한 지식 필요)
2. 뷰모델이 비대해질 수 있다.
3. 데이터 바인딩으로 인한 메모리 소모가 심하다.
4. ViewModel 설계가 복잡하다

# 패러다임

> 어떤 한 시대 사람들의 견해나 사고를 근본적으로 규정하고 있는 테두리로서의 인식의 체계
또는 사물에 대한 이론적인 틀이나 체계를 의미하는 개념

프로그래밍 패러다임이란 프로그래밍의 관점을 갖게 하는 개발 방법론
> 

## 선언형/함수형

## 선언형

> 프로그램이 무엇을 하는지를 설명하는 패러다임
제어 흐름을 명시적으로 지정하지 않는다.
무엇을 원하는지에 집중하며 세부적인 구현 방법은 추상화된다.
> 

## 선언형 프로그래밍의 장점

1. 가독성이 높다
2. 재사용성이 높다
3. 프로그램 동작을 변경하지 않고도 관련 값을 대체할 수 있다.
4. 해당 언어에서 문제가 발생해도 다른 것에 영향을 주지 않는다.

## 함수형

> 상태 및 데이터 변경에는 사용하지 않으며 작은 문제를 해결하기 위한 `함수(function)` 단위로 개발을 하는 기법을 지향하는 프로그래밍 기법
> 

## 함수형 프로그래밍의 장점

1. 불변성과 예측 가능성
2. 병렬 처리 및 동시성
3. 모듈화와 재사용성
4. 테스트 용이성
5. 표현력과 가독성

## 함수형 프로그래밍의 단점

1. 학습 곡선
2. 성능 오버헤드
3. 적은 생태계
4. 상태 변화 처리

## 객체지향/절차형

## 객체 지향 프로그래밍(OOP: Object-Oriented Programming)

> 어떤 일을 해결 하기 위해 수많은 객체(Object)들을 기본 단위로 나누고 서로 간의 상호관계 작용으로 개발하는 것을 지향하는 프로그램

명령형 프로그래밍의 일종이고 객체들의 집합으로 프로그램의 상호 작용을 표현하며 데이터를 객체로 취급하여 객체 내부에 선언된 메서드를 활용하는 방식
> 

## 객체지향 프로그래밍의 4가지 특징

1. 추상화
    1. 복잡한 시스템으로부터 핵심적인 개념 또는 기능을 간추려내는 것을 의미
2. 캡슐화
    1. 객체의 속성과 메서드를 하나로 묶고 일부를 외부에 감추어 은닉하는 것
3. 상속성
    1. 상위 클래스의 특성을 하위 클래스가 이어받아서 재사용하거나 추가, 확장하는 것
4. 다형성
    1. 하나의 메서드가 다양한 방법으로 동작하는 것

## 절차 지향 프로그래밍(PP: Procedural Programming)

> 절차지향이란 물이 위에서 아래로 흐르는 것처럼 순차적인 처리가 중요시되며 프로그램 전체가 유기적으로 연결되도록 만드는 프로그래밍 기법
> 

## 절차지향 특징

- 컴퓨터의 작업 처리 방식과 유사하기 때문에 객체지향 언어를 사용하는 것에 비해 더 빨리되어 시간적으로 유리
- 하나의 큰 기능을 처리하기 위해 작은 단위의 기능들로 나누어 처리하는 Top-Down 접근 방식으로 설계된다.
- 데이터와 함수를 별개로 취급한다.
- 모든 함수는 데이터 공유가 가능하다.
- 정해진 순서대로 입력해야 하므로 순서가 바뀌면 결과를 도출하기 어렵다.
- 프로그램이 커질수록 구조가 복잡해져 유지보수가 어렵다. (소형 프로젝트에 적합)

## 패러다임 혼합

> 프로그래밍에서 “패러다임 혼합”이란 서로 다른 프로그래밍 패러다임을 결합하여 사용하는 것을 의미
각각의 프로그래밍 패러다임은 특정한 방식으로 문제를 해결하고 코드를 구성하는데 사용
> 

## 객체 지향과 절차형 혼합

> 객체 지향 프로그래밍과 절차형 프로그래밍을 혼합하여 사용하는 경우가 많다.
객체 지향의 장점인 모듈화와 재사용성을 활용하면서 일부 성능이 중요한 부분에서는절차형 방식으로 최적화된 코드를 작성할 수 있다.
> 

## 함수형과 객체 지향 혼합

> 함수형 프로그래밍과 객체 지향 프로그래밍을 혼합하여 사용하는 경우에는 함수형 프로그래밍의 불변성과 함수 조합성을 객체 지향의 모듈화와 함께 활용할 수 있다.
이는 복잡한 문제를 해결할 때 높은 수준의 추상화와 유연성을 제공.
> 

## 이벤트 기반 지향 혼합

> 이벤트 기반 프로그래밍과 객체 지향 프로그래밍을 혼합하여 사용하는 경우에는 이벤트 처리와 상태관리를 객체 지향 방식으로 구현할 수 있다.
예를 들어, GUI 애플리케이션에서는 이벤트 기반 방식으로 사용자의 동작에 반응하면서도 객체 지향적인설계를 유지.
>